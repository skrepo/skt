[comment {-*- tcl -*- doctools manpage}]
[vset VERSION 0.1.0]
[manpage_begin csp n [vset VERSION]]
[keywords csp]
[keywords golang]
[keywords concurrency]
[keywords callback]
[keywords channel]
[copyright {2015 SecurityKISS Ltd <open.source@securitykiss.com> - MIT License}]
[titledesc {Golang style concurrency library based on Communicating Sequential Processes}]
[moddesc   {Concurrency}]
[category  {Concurrency}]
[require Tcl 8.6]
[require csp [opt [vset VERSION]]]
[description]
[para]
The [package csp] package provides two concurrency primitives namely [term coroutines] and [term channels] which allow concurrent programming in the style of [uri https://en.wikipedia.org/wiki/Go_(programming_language) Golang].
[para]
The concepts originate in Hoare's [uri https://en.wikipedia.org/wiki/Communicating_sequential_processes {Communicating Sequential Processes}] while the syntax mimics the Golang implementation.
[para]
The CSP concurrency model may be visualized as a set of independent processes (coroutines) sending and receiving messages to the named channels. The control flow in the coroutines is coordinated at the points of sending and receiving messages i.e. the coroutine may need to wait while trying to send or receive.
Since it must work in a single-threaded interpreter, waiting is non-blocking. Instead of blocking a waiting coroutine gives way to other coroutines.
[para]

[section Concepts]

[list_begin definitions]

[def [cmd channel]]

    [list_begin definitions]
    [def {There are two types of channels.}]
        [list_begin definitions]
            
            [def [term {Unbuffered channels}]]
            [para]
            The unbuffered channel is a single value container that can be imagined as a rendez-vous venue where the sender must wait for the receiver to collect the message.
            By default channels are unbuffered. 
            
            [def [term {Buffered channels}]]
            [para]
            The buffered channel behaves like a FIFO queue. 
        [list_end]
    [list_end]

    [para]
    [list_begin definitions]
    [def {Whether receiver need to wait while trying to receive from a channel depends on the channel's internal state:}]
        [list_begin definitions]
        [def [term {ready for receive}]]
            The buffered channel is ready for receive when it is not empty.
            The unbuffered channel is ready for receive if there exists a sender waiting with a message on this channel.
    
        [def [term {ready for send}]]
            The buffered channel is ready for send when it is not full.
            The unbuffered channel is ready for send if there is no other sender already waiting on this channel. Note that 
        [list_end]
    [list_end]


    channel chanVar ?size?
    $chanVar close

    If size is zero (default) the created channel is unbuffered.

    
    [para]
    [list_begin definitions]
    [def {Channel lifecycle is described by 3 possible states:}]
        [list_begin definitions]
            [def [term created]]
            Once the channel is created you can send to and receive from the channel.
            [def [term closed]]
            When the channel is closed you can still receive from the channel but you cannot send to it.
            Trying to send to the closed channel throws an error.
            It is responsibility of the library user to close the unused channels.
            [def [term destroyed]]
            The channel does not exist. 
            After receiving all messages from the closed channel, the channel is destroyed.
            Trying to send to or receive from the destroyed channel throws an error.
        [list_end]
    [list_end]
    Note that creating a large number of channels that are properly closed but not emptied may result in a memory leak.


[def [cmd coroutine]]
    Coroutine is a procedure executing concurrently with other coroutines. 
    Created:
        go procName ?args?

    procName is the name of the existing Tcl procedure that will be run as a coroutine.
    You can create many coroutines from a single Tcl procedure, possibly called with different arguments

    Coroutine is destroyed when its execution ends.


    Coroutines are multiplexed 
    gives way to other coroutines


    Coroutines may send messages to channels and receive messages from channels. Any coroutine may act as a sender or receiver at different times. 

[list_end]

[section COMMANDS]

[para]

[list_begin definitions]
[call [cmd ::csp::go] [arg procName] [opt [arg args]]]    
    Create a coroutine by calling [arg procName] with arguments [arg args]
[call [cmd ::csp::channel] [arg channelVar] [opt [arg size]]]
    Create a channel object that will be contained in variable [arg channelVar].
    [list_begin arguments]
        [arg_def var channelVar]
        [arg_def number size]
    [list_end]
    
[call [cmd channelObj] [arg close]]
    Close the channel [arg channelObj]

[call [cmd channelObj] [arg <-] [arg msg]]
    Send [arg msg] to channel [arg channelObj] in a coroutine.
    
[call [cmd channelObj] [arg <-!] [arg msg]]
    Send [arg msg] to channel [arg channelObj] in a script (in the Tcl program main control flow).
    
[call [cmd ::csp::<-] [arg channelObj]]
    Receive from channel [arg channelObj] in a coroutine.

[call [cmd ::csp::<-!] [arg channelObj]]
    Receive from channel [arg channelObj] in a script (in the Tcl program main control flow).

[call [cmd ::csp::select] [arg operation] [arg body]]
    
[call [cmd ::csp::range] [arg varName] [arg channelObj] [arg body]]

[call [cmd ::csp::range!] [arg varName] [arg channelObj] [arg body]]

[call [cmd ::csp::timer] [arg channelVar] [arg ms]]

[call [cmd ::csp::ticker] [arg channelVar] [arg ms]]

[call [cmd ::csp::->] [arg channelVar] [opt [arg size]]]

[call [cmd ::csp::->>] [arg channelVar] [opt [arg size]]]

[para]

[list_end]

[section EXAMPLES]
[subsection {Example 1}]
Simple message passing over an unbuffered channel
[example {
    package require csp
    namespace import csp::*
    proc sender1 {ch} {
        foreach i {1 2 3 4} {
            puts "Sending $i"
            $ch <- $i
        }
        puts "Closing channel"
        $ch close
    }
    proc receiver1 {ch} {
        while 1 {
            puts "Receiving [<- $ch]"
        }
    }
    # create unbuffered (rendez-vous) channel
    channel ch
    go sender1 $ch
    go receiver1 $ch
    vwait forever
}]

Output:

[example {
Sending 1
Receiving 1
Sending 2
Receiving 2
Sending 3
Receiving 3
Sending 4
Receiving 4
Closing channel
}]

The communication between the coroutines is coordinated because the channel is unbuffered.
The sender waits for the receiver.


[subsection {Example 2}]
Simple message passing over a buffered channel

[example {
    package require csp
    namespace import csp::*
    proc sender1 {ch} {
        foreach i {1 2 3 4} {
            puts "Sending $i"
            $ch <- $i
        }
        puts "Closing channel"
        $ch close
    }
    proc receiver1 {ch} {
        while 1 {
            puts "Receiving [<- $ch]"
        }
    }
    # create buffered channel of size 2
    channel ch 2
    go sender1 $ch
    go receiver1 $ch
    vwait forever
}]

Output:

[example {
Sending 1
Sending 2
Sending 3
Receiving 1
Receiving 2
Sending 4
Closing channel
Receiving 3
Receiving 4
Error: Cannot receive from a drained (empty and closed) channel ::csp::Channel#1
}]
[para]
Since the channel is buffered of size 2, the sender waits only on the third attempt.
[para]
Note that the channel was closed but we still receive messages. Only after the channel was emptied, trying to receive from the channel throws an error.


[subsection {Example 3}]
[para]
Using [cmd range] for receiving from the channel until closed.
[para]
We can prevent throwing the error in the previous example by using the [cmd range] command instead of iterating blindly with [cmd while].
Also if the channel is buffered we can send all messages first and iterate to receive using [cmd range] in a single coroutine.

[example {
    package require csp
    namespace import csp::*

    proc senderreceiver {ch} {
        foreach i {1 2 3 4} {
            puts "Sending $i"
            $ch <- $i
        }
        puts "Closing channel"
        $ch close
        range msg $ch {
            puts "Message $msg"
        }
        puts "Received all"
    }
    channel ch 10
    go senderreceiver $ch
    vwait forever
}]

Output:

[example {
Sending 1
Sending 2
Sending 3
Sending 4
Closing channel
Message 1
Message 2
Message 3
Message 4
Received all
}]

[manpage_end]
