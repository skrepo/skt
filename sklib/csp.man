[comment {-*- tcl -*- doctools manpage}]
[vset VERSION 0.1.0]
[manpage_begin csp n [vset VERSION]]
[keywords csp]
[keywords golang]
[keywords concurrency]
[keywords callback]
[keywords channel]
[keywords actors]
[copyright {2015 SecurityKISS Ltd <open.source@securitykiss.com> - MIT License - Bug reports and feedback are welcome}]
[titledesc {Golang style concurrency library based on Communicating Sequential Processes}]
[moddesc   {Concurrency}]
[category  {Concurrency}]
[require Tcl 8.6]
[require csp [opt [vset VERSION]]]
[description]
[para]
The [package csp] package provides two concurrency primitives namely [term coroutines] and [term channels] which allow concurrent programming in the style of [uri https://en.wikipedia.org/wiki/Go_(programming_language) Golang].
[para]
The concepts originate in Hoare's [uri https://en.wikipedia.org/wiki/Communicating_sequential_processes {Communicating Sequential Processes}] while the syntax mimics the Golang implementation.
[para]
The CSP concurrency model may be visualized as a set of independent processes (coroutines) sending and receiving messages to the named channels. The control flow in the coroutines is coordinated at the points of sending and receiving messages i.e. the coroutine may need to wait while trying to send or receive.
Since it must work in a single-threaded interpreter, waiting is non-blocking. Instead of blocking a waiting coroutine gives way to other coroutines.
[para]

[section Concepts]

[list_begin definitions]

[def [cmd channel]]

    [list_begin definitions]
    [def {There are two types of channels.}]
        [list_begin definitions]
            
            [def [term {Unbuffered channels}]]
            [para]
            The unbuffered channel is a single value container that can be imagined as a rendez-vous venue where the sender must wait for the receiver to collect the message.
            By default channels are unbuffered. 
            
            [def [term {Buffered channels}]]
            [para]
            The buffered channel behaves like a FIFO queue. 
        [list_end]
    [list_end]

    [para]
    [list_begin definitions]
    [def {Whether receiver need to wait while trying to receive from a channel depends on the channel's internal state:}]
        [list_begin definitions]
        [def [term {ready for receive}]]
            The buffered channel is ready for receive when it is not empty.
            The unbuffered channel is ready for receive if there exists a sender waiting with a message on this channel.
    
        [def [term {ready for send}]]
            The buffered channel is ready for send when it is not full.
            The unbuffered channel is ready for send if there is no other sender already waiting on this channel. Note that 
        [list_end]
    [list_end]


    channel chanVar ?size?
    $chanVar close

    If size is zero (default) the created channel is unbuffered.

    
    [para]
    [list_begin definitions]
    [def {Channel lifecycle is described by 3 possible states:}]
        [list_begin definitions]
            [def [term created]]
            Once the channel is created you can send to and receive from the channel.
            [def [term closed]]
            When the channel is closed you can still receive from the channel but you cannot send to it.
            Trying to send to the closed channel throws an error.
            It is responsibility of the library user to close the unused channels.
            [def [term destroyed]]
            The channel does not exist. 
            After receiving all messages from the closed channel, the channel is destroyed.
            Trying to send to or receive from the destroyed channel throws an error.
        [list_end]
    [list_end]
    Note that creating a large number of channels that are properly closed but not emptied may result in a memory leak.


[def [cmd coroutine]]
    Coroutine is a procedure executing concurrently with other coroutines. 
    Created:
        go procName ?args?

    procName is the name of the existing Tcl procedure that will be run as a coroutine.
    You can create many coroutines from a single Tcl procedure, possibly called with different arguments

    Coroutine is destroyed when its execution ends.


    Coroutines are multiplexed 
    gives way to other coroutines


    Coroutines may send messages to channels and receive messages from channels. Any coroutine may act as a sender or receiver at different times. 

[list_end]

[section COMMANDS]

[para]

[list_begin definitions]
[call [cmd ::csp::go] [arg procName] [opt [arg args]]]    
    Create a coroutine by calling [arg procName] with arguments [arg args]
[call [cmd ::csp::channel] [arg channelVar] [opt [arg size]]]
    Create a channel object that will be contained in variable [arg channelVar].
    [list_begin arguments]
        [arg_def var channelVar]
        [arg_def number size]
    [list_end]
    
[call [cmd channelObj] [arg close]]
    Close the channel [arg channelObj]

[call [cmd channelObj] [arg <-] [arg msg]]
    Send [arg msg] to channel [arg channelObj] in a coroutine.
    
[call [cmd channelObj] [arg <-!] [arg msg]]
    Send [arg msg] to channel [arg channelObj] in a script (in the Tcl program main control flow).
    
[call [cmd ::csp::<-] [arg channelObj]]
    Receive from channel [arg channelObj] in a coroutine.

[call [cmd ::csp::<-!] [arg channelObj]]
    Receive from channel [arg channelObj] in a script (in the Tcl program main control flow).

[call [cmd ::csp::select] [arg operation] [arg body]]
    
[call [cmd ::csp::range] [arg varName] [arg channelObj] [arg body]]

[call [cmd ::csp::range!] [arg varName] [arg channelObj] [arg body]]

[call [cmd ::csp::timer] [arg channelVar] [arg ms]]

[call [cmd ::csp::ticker] [arg channelVar] [arg ms]]

[call [cmd ::csp::->] [arg channelVar] [opt [arg size]]]

[call [cmd ::csp::forward] [arg fromChannel] [arg toChannel]]

[para]

[list_end]

[section EXAMPLES]
[subsection {Example 1}]
Simple message passing over an unbuffered channel
[example {
    package require csp
    namespace import csp::*
    proc sender1 {ch} {
        foreach i {1 2 3 4} {
            puts "Sending $i"
            $ch <- $i
        }
        puts "Closing channel"
        $ch close
    }
    proc receiver1 {ch} {
        while 1 {
            puts "Receiving [<- $ch]"
        }
    }
    # create unbuffered (rendez-vous) channel
    channel ch
    go sender1 $ch
    go receiver1 $ch
    vwait forever
}]

Output:

[example {
Sending 1
Receiving 1
Sending 2
Receiving 2
Sending 3
Receiving 3
Sending 4
Receiving 4
Closing channel
}]

The communication between the coroutines is coordinated because the channel is unbuffered.
The sender waits for the receiver.


[subsection {Example 2}]
Simple message passing over a buffered channel

[example {
    package require csp
    namespace import csp::*
    proc sender1 {ch} {
        foreach i {1 2 3 4} {
            puts "Sending $i"
            $ch <- $i
        }
        puts "Closing channel"
        $ch close
    }
    proc receiver1 {ch} {
        while 1 {
            puts "Receiving [<- $ch]"
        }
    }
    # create buffered channel of size 2
    channel ch 2
    go sender1 $ch
    go receiver1 $ch
    vwait forever
}]

Output:

[example {
Sending 1
Sending 2
Sending 3
Receiving 1
Receiving 2
Sending 4
Closing channel
Receiving 3
Receiving 4
Error: Cannot receive from a drained (empty and closed) channel ::csp::Channel#1
}]
[para]
Since the channel is buffered of size 2, the sender waits only on the third attempt.
[para]
Note that the channel was closed but we still receive messages. Only after the channel was emptied, trying to receive from the channel throws an error.




[subsection {Example 3}]
[para]
Using [cmd range] for receiving from the channel until closed.
[para]
We can prevent throwing the error in the previous example by using the [cmd range] command instead of iterating blindly with [cmd while].
Also if the channel is buffered we can send all messages first and iterate to receive using [cmd range] in a single coroutine.

[example {
    package require csp
    namespace import csp::*

    proc senderreceiver {ch} {
        foreach i {1 2 3 4} {
            puts "Sending $i"
            $ch <- $i
        }
        puts "Closing channel"
        $ch close
        range msg $ch {
            puts "Message $msg"
        }
        puts "Received all"
    }
    channel ch 10
    go senderreceiver $ch
    vwait forever
}]

Output:

[example {
Sending 1
Sending 2
Sending 3
Sending 4
Closing channel
Message 1
Message 2
Message 3
Message 4
Received all
}]





[subsection {Example 4}]
[para]
Channels can be used to coordinate future events. We use [cmd after] to create coroutine that will send to the channel. 
[para]
Instead of using direct callback which cannot keep local state we consume events in [cmd adder] which can keep sum in local variable.
[para]
[example {
    package require csp
    namespace import csp::*
    proc adder {ch} {
        set sum 0
        while 1 {
            set number [<- $ch]
            incr sum $number
            puts "adder received $number. The sum is $sum"
        }
    }
    proc trigger {ch number} {
        $ch <- $number
    }
    channel ch
    go adder $ch
    after 1000 go trigger $ch 1
    after 3000 go trigger $ch 3
    after 5000 go trigger $ch 5
    puts "Enter event loop"
    vwait forever
}]

Output:

[example {
Enter event loop
adder received 1. The sum is 1
adder received 3. The sum is 4
adder received 5. The sum is 9
}]





[subsection {Example 5}]
[para]
Use [cmd timer] to create a channel supplying scheduled messages in the future.
[para]
[example {
    package require csp
    namespace import csp::*

    proc future {ch} {
        try {
            puts "future happened at  [<- $ch]"
            puts "try to receive again:"
            puts "[<- $ch]"
        } on error {out err} {
            puts "error: $out"
        }
    }

    timer ch 2000
    go future $ch
    puts "Enter event loop at [clock microseconds]"
    vwait forever
}]

Output:

[example {
Enter event loop at 1434472163190638
future happened at  1434472165189759
try to receive again:
error: Cannot receive from a drained (empty and closed) channel ::csp::Channel#1
}]
[para]

Instead of scheduling events with [cmd after] we can use [cmd timer] to create a special receive only channel. There will be only one message send to this channel after the specified time so we can pass this channel to another coroutine that will wait for that message. The message from the timer channel represents unix epoch time in microseconds. The timer channel will be automatically destroyed after first receive so trying to receive again will throw an error.





[subsection {Example 6}]
[para]
Using [cmd ticker] we can create receive only channel from which we can consume timestamp messages at regular intervals.

[example {
    package require csp
    namespace import csp::*

    proc future {ch} {
        set count 0
        while 1 {
            incr count
            puts "future $count received at [<- $ch]"
        }
    }

    ticker ch 1000
    go future $ch
    puts "Enter event loop at  [clock microseconds]"
    vwait forever
}]

Output:

[example {
Enter event loop at  1434472822879684
future 1 received at 1434472823879110
future 2 received at 1434472824882163
future 3 received at 1434472825884246
...
}]




[subsection {Example 7}]
[para]

[cmd ticker] command returns the created channel so we can use it in place in combination with [cmd range] to further simplify the example

[example {
    package require csp
    namespace import csp::*
    proc counter {} {
        range t [ticker ch 1000] {
            puts "received $t"
        }
    }
    go counter
    vwait forever
}]

Output:

[example {
received 1434474325947677
received 1434474326950822
received 1434474327952904
...
}]





[subsection {Example 8}]
[para]
Closing the channel by another scheduled event breaks the [cmd range] loop

[example {
    package require csp
    namespace import csp::*
    proc counter {ch} {
        range t $ch {
            puts "received $t"
        }
        puts "counter exit"
    }
    ticker ch 1000
    go counter $ch
    after 4500 $ch close
    puts "Enter event loop at [clock microseconds]"
    vwait forever
}]

Output:

[example {
Enter event loop at 1434474384645704
received 1434474385644900
received 1434474386648105
received 1434474387650088
received 1434474388652345
counter exit
}]



[subsection {Example 9}]
[para]
Redirect callback call argument to a channel using [cmd ->] command.

[example {
    package require http
    package require csp
    namespace import csp::*
    proc main {} {
        http::geturl http://securitykiss.com/rest/now -command [-> ch]
        puts "fetched: [http::data [<- $ch]]"
    }
    go main
    vwait forever
}]

Output:

[example {
fetched: 1434474568
}]

[para]
[package csp] package makes it easy to integrate channels and coroutines with existing event driven code.
Using the [cmd ->] utility command we can make channels work with callback driven commands and at the same time avoid callback hell.
[para]
[cmd ->] [arg ch] creates a channel ch and returns a new coroutine that may be used in place of a callback.
The channel will be destroyed after receiving a single value.
The single argument passed to the callback will be available to receive from the created channel.
[para]
Such code organization promotes local reasoning - it helps writing linear code with local state kept in proc variables. Otherwise the callback would require keeping state in global variables.
[para]
Note that there is a limitation in replacing callbacks with [cmd ->] command: only a single- or zero- argument callbacks can be replaced.
In case of zero-argument callbacks an empty string is sent to the channel.



[subsection {Example 10}]
[para]
Use [cmd select] command to choose ready channels.

[example {
    package require http
    package require csp
    namespace import csp::*
    proc main {} {
        http::geturl http://securitykiss.com/rest/slow/now -command [-> ch1]
        http::geturl http://securitykiss.com/rest/slow/now -command [-> ch2]
        select {
            <- $ch1 {
                puts "from first request: [http::data [<- $ch1]]"
            }
            <- $ch2 {
                puts "from second request: [http::data [<- $ch2]]"
            }
        }
    }
    go main
    vwait forever
}]

Output:

[example {
from first request: 1434483100
}]

[para]
Previous example with callback channels does not extend to making parallel http requests because one waiting channel would prevent receiving from the other.
The [cmd select] command chooses which of a set of possible send or receive operations will proceed. In this example [cmd select] command examines two callback channels and depending on which one is ready for receive first, it evaluates corresponding body block.


[subsection {Example 11}]
[para]
Combine [cmd timer] created channel with [cmd select] to enforce timeouts.
[example {
    package require http
    package require csp
    namespace import csp::*
    proc main {} {
        http::geturl http://securitykiss.com/rest/slow/now -command [-> ch1]
        http::geturl http://securitykiss.com/rest/slow/now -command [-> ch2]
        timer t1 400
        select {
            <- $ch1 {
                puts "from first request: [http::data [<- $ch1]]"
            }
            <- $ch2 {
                puts "from second request: [http::data [<- $ch2]]"
            }
            <- $t1 {
                puts "requests timed out at [<- $t1]"
            }
        }
    }
    go main
    vwait forever
}]

Output:

[example {
requests timed out at 1434484003634953
}]
[para]
Since [cmd select] chooses from the set of channels whichever is ready first, by adding the [cmd timer] created channel to select from, we can implement timeout as in the example above.



[subsection {Example 12}]
[para]
Use [cmd select] with the default clause.

[example {
    package require http
    package require csp
    namespace import csp::*
    proc DisplayResult {ch1 ch2} {
        set result [select {
            <- $ch1 {
                http::data [<- $ch1]
            }
            <- $ch2 {
                http::data [<- $ch2]
            }
            default {
                subst "no response was ready"
            }
        }]
        puts "DisplayResult: $result"
    }
    proc main {} {
        http::geturl http://securitykiss.com/rest/slow/now -command [-> ch1]
        http::geturl http://securitykiss.com/rest/slow/now -command [-> ch2]
        after 400 go DisplayResult $ch1 $ch2
    }
    go main
    vwait forever
}]

Output:

[example {
DisplayResult: no response was ready
}]

[para]
[cmd select] command is potentially waiting if no channel is ready. Sometimes we need to proceed no matter what so [cmd select] makes it possible to return without waiting if the [cmd default] clause is provided. This example also shows that [cmd select] has a return value. In this case the result returned by [cmd select] is either HTTP response or the value specified in the default block if no channel is ready.




[subsection {Example 13}]
[para]

[example {

}]

Output:

[example {

}]




[subsection {Example 7}]
[para]

[example {

}]

Output:

[example {

}]



[subsection {Example 7}]
[para]

[example {

}]

Output:

[example {

}]


[manpage_end]
